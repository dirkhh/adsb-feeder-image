#!/bin/bash

#all errors will show a line number and the command used to produce the error
# shellcheck disable=SC2148,SC2164
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND"' ERR

# this needs to run as root
if [ "$(id -u)" != "0" ] ; then
    echo "this command requires superuser privileges - please run as sudo bash $0"
    exit 1
fi

start_wait_app() {
    python3 /opt/adsb/adsb-setup/waiting-app.py "$@" &>> /opt/adsb/adsb-setup.log
}
kill_wait_app() {
    PORT=$(grep AF_WEBPORT /opt/adsb/config/.env | cut -d= -f2)
    PORTHEX=$(printf "%04x" "$PORT")

    # figure out if something is listening to that port and give it some time to stop running
    # keep killing the wait the app while waiting for the port
    for i in {1..100}; do
        pkill -f 'python3 /opt/adsb/adsb-setup/waiting-app.py' || true
        sleep 0.1
        if ! grep /proc/net/tcp -F -e ": 00000000:${PORTHEX}" -qs; then
            return
        fi
    done
    # let's complain loudly once we've been unsuccessful for 10 seconds
    echo "$(date -u +"%FT%T.%3NZ") FATAL: There's still something running on port $PORT but not waiting anymore"
    netstat -tlpn
}

# little silly helper functions
exit_with_message() { echo "$1" ; exit 1 ; }
cleanup() {
    # assuming things aren't too screwed up, let's try to start docker
    # and the setup app
    # that way the user might at least be able to look at the logs and figure out
    # what went wrong (or at least ask for help with more information)
    # make sure this doesn't fail if the kill fails for some reason
    kill_wait_app
    /opt/adsb/docker-compose-start
    systemctl restart adsb-setup.service
}

waiting_placeholder() {
    # make sure the waiting app isn't around anymore and the port is available
    kill_wait_app

    # finally start the waiting-app
    start_wait_app "$PORT" /opt/adsb/adsb-setup.log "Updating the" &
}

# if this is an update where the previous version of the image used /var/log/adsb-setup.log
# and this is the first time we use the new location, copy the existing log over
[ ! -f /opt/adsb/adsb-setup.log ] && [ -f /var/log/adsb-setup.log ] && cp /var/log/adsb-setup.log /opt/adsb/adsb-setup.log

exec 3>&1
exec &>>/opt/adsb/adsb-setup.log

# identify the calling process for better log messages
PARENTPID=$(ps -cp $$ -o ppid="")
if kill -0 "$PARENTPID" &> /dev/null ; then
    # shellcheck disable=SC2086 # the ps -q call fails with quotes around the variable
    PARENTPROC=$(ps -q$PARENTPID -o args=)
else
    PARENTPROC="process $PARENTPID (appears already gone)"
fi
echo "$(date -u +"%FT%T.%3NZ") $PARENTPROC called feeder-update" "$@"
echo "$(date -u +"%FT%T.%3NZ") $PARENTPROC called feeder-update" "$@" >&3

trap cleanup EXIT

LAST_ARG=${!#}
if [[ $LAST_ARG == "-go" ]]; then
    # that means we just refreshed the git tree and the first argument is the target
    TARGET="$1"
    BRANCH="$2"
else
    if [[ $LAST_ARG == "-wait" ]]; then
        # we were called from the feeder-update-service... and in order for the web UI to be
        # able to wait for the update to succeed, we need to give it a few seconds to show the
        # waiting page and set things up
        sleep 5
    fi
    # this makes sure that the user can't interact with the UI while we are potentially
    # making changes under the hood
    echo "stop the running service"
    systemctl stop adsb-setup.service
    waiting_placeholder

    # we want to get the correct (matching) update script. But to do
    # that we need to figure out which one that is.
    # (that last arg pattern has downsides... we can't just skip them, so filter out non-branch arguments here)
    if [[ "$1" == "" || "$1" == -* ]] ; then
        # called without argument, so check which channel we are updating to
        if [ -f /opt/adsb/update-channel ] ; then
            TARGET=$(</opt/adsb/update-channel)
        else
            # ok, no channel either... can we guess from the current version?
            TARGET=$(sed 's/.*(\(.*\)).*/\1/' < /opt/adsb/adsb.im.version)
            if [ "$TARGET" = "$(cat /opt/adsb/adsb.im.version)" ] ; then
                # running out of ideas - let's just go with stable
                BRANCH="stable"
            fi
        fi
    else
        # the command line told us what to get. Nice.
        TARGET="$1"
    fi
    [ -z "$BRANCH" ] && BRANCH="$TARGET"
    mkdir -p /opt/adsb-feeder-update
    # make sure the git dir is up to date
    # don't hide the output as that could be useful in the logs
    if ! cd /opt/adsb-feeder-update/adsb-feeder-image || ! git fetch; then
        cd /opt/adsb-feeder-update || exit_with_message "can't cd /opt/adsb-feeder-update"
        rm -rf /opt/adsb-feeder-update/adsb-feeder-image
        git clone https://github.com/dirkhh/adsb-feeder-image || exit_with_message "git clone failed, giving up"
        cd adsb-feeder-image || exit_with_message "can't cd /opt/adsb-feeder-update/adsb-feeder-image"
    fi
    # 'stable' and 'beta' are special, they refer to tags.
    # everything else is interpreted as a branch or a hash
    if [[ "$TARGET" == "beta" ]] ; then
        # for the beta channel, grab the last beta tag
        TARGET=$(git tag --merged origin/beta --sort=version:refname | grep '^v[0-9]' | tr - \~ | sort -V | tr \~ - | tail -1) || exit_with_message "error finding tag, giving up"
    elif [[ "$TARGET" == "stable" ]] ; then
        # for the stable channel, grab the last non-beta tag
        TARGET=$(git tag --merged origin/stable --sort=version:refname | grep '^v[0-9]'| tr - \~ | sort -V | tr \~ - | tail -1) || exit_with_message "error finding tag, giving up"
    fi
    git reset --hard "$TARGET" || exit_with_message "git reset --hard $TARGET failed, giving up"
    echo "restarting with feeder-update from $TARGET"
    if [ ! -f src/modules/adsb-feeder/filesystem/root/opt/adsb/feeder-update ] ; then
        echo "can't find the feeder-update app in the git tree, using existing one"
        cp "$0" /opt/adsb-feeder-update/feeder-update
    else
        cp src/modules/adsb-feeder/filesystem/root/opt/adsb/feeder-update /opt/adsb-feeder-update/feeder-update
    fi
    # add a trailing '-go' argument, and the correct target as first argument; this way the call should
    # be compatible with older versions of the script - not that anyone should want to downgrade using this script
    XTRACE="" && [[ -o xtrace ]] && XTRACE="-x"
    if [ -f /opt/adsb-feeder-update/feeder-update ] ; then
        # the cleanup trap will be re-initialized in the child script, so disable it here
        trap - EXIT
        bash $XTRACE /opt/adsb-feeder-update/feeder-update "$TARGET" "$BRANCH" "$@" -go
        echo "$(date -u +"%FT%T.%3NZ") update complete" >&3
    else
        echo "can't find /opt/adsb-feeder-update/feeder-update after update to $TARGET"
    fi
    exit "$?"
fi

# now we know that we are running the right script in the right place
DIR=$(dirname -- "$(readlink -f "${BASH_SOURCE[0]}")")
echo "running ${DIR}/feeder-update from $TARGET"

# we know that the adsb-setup app has been shut down so, let's do a quick backup of the config data
mkdir -p /opt/adsb/config/backups
TIMESTAMP=$(date +%Y-%m-%d+%H:%M)
cp /opt/adsb/config/.env /opt/adsb/config/backups/env."$TIMESTAMP" &> /dev/null
cp /opt/adsb/config/config.json /opt/adsb/config/backups/config.json."$TIMESTAMP" &> /dev/null

cd "${DIR}/adsb-feeder-image" || exit_with_message "can't cd to ${DIR}/adsb-feeder-image"

# grab the most recent version tag. Forcing '--long' always adds the -<num>-g<sha> trailer to the result - which we then can remove
TAG_COMPONENT=$(git describe --match "v[0-9]*" --long | sed "s/-[0-9]*-g[0-9a-f]*//")
# now comare this to a regular call to git describe so we get the SHA that we'll add at the end
DESCRIBE=$(git describe --match "v[0-9]*")
SHA_COMPONENT=${DESCRIBE//$TAG_COMPONENT/}
VERSION="${TAG_COMPONENT}(${BRANCH})${SHA_COMPONENT}"
echo "starting the actual upgrade to ${VERSION}"

# we now need the Python3 requests module and that may not have been installed originally
missing=()
if ! python3 -c "import requests" &>/dev/null ; then
    missing+=("python3-requests")
fi
if [[ ${#missing[@]} -gt 0 ]] ; then
    # let's try to install it
    echo "newer versions of the adsb.im ADS-B Feeder Image require the Python3 ${missing[@]} package(s) - trying to install"
    grep -i fedora /etc/os-release &> /dev/null && dnf install -y "${missing[@]}"
    grep -i centos /etc/os-release &> /dev/null && dnf install -y "${missing[@]}"
    grep -i suse /etc/os-release &> /dev/null && zypper install -y "${missing[@]}"
    grep -i debian /etc/os-release &> /dev/null && apt-get install -y "${missing[@]}"
    # now let's check again
    if ! python3 -c "import requests" &>/dev/null ; then
        echo "cannot install Python3 requests package - please contact the adsb.im maintainer"
        exit 1
    fi
fi

echo "prepare the files that we need to replace"
mkdir -p "${DIR}/root"
cp -r src/modules/adsb-feeder/filesystem/root "${DIR}"

echo "copy the updated files in place"
# shellcheck disable=SC2164
cd "${DIR}/root"


# remove adsb.im services from /etc/systemd/system that were previously placed there
services=(adsb-bootstrap.service  adsb-docker.service  adsb-feeder-update.service  adsb-hotspot.service  adsb-nonimage.service  adsb-setup.service  adsb-update.service  adsb-update.timer)
for service in "${services[@]}"; do
    rm -vf "/etc/systemd/system/$service"
done

services_enable=()

# if this an app and not the full image, prune some of the files that aren't wanted for the app
# wanted for the app and copy the trees we need over
if [ ! -f /opt/adsb/os.adsb.feeder.image ] ; then
    rm -f ./usr/lib/systemd/system/adsb-hotspot.service
    rm -f ./usr/lib/systemd/system/adsb-bootstrap.service
    cp -v -a -t ./usr/lib/systemd/system/* /usr/lib/systemd/system/
    cp -v -a -t /opt/adsb/* /opt/adsb
else
    # copy the complete tree into the / filesystem
    cp -v -a -r . /

    services_enable+=("adsb-hotspot.service")
fi

echo "$(date -u +"%FT%T.%3NZ") updating systemd services ..."

services_enable+=("adsb-docker.service")

# the timer is gonna start the service
# if the service is enabled it's gonna start on boot which is not the desired behaviour
systemctl disable adsb-update.service

services_enable+=("adsb-update.timer")
services_enable+=("adsb-setup.service")

systemctl enable "${services_enable[@]}"

systemctl daemon-reload

echo "$(date -u +"%FT%T.%3NZ") updating systemd services ... done"

# shellcheck disable=SC2164
cd /opt/adsb

# make sure the version information is correct
# deal with remote branches like origin/somebranch that contain forward slashes
# and end up being part of the VERSION string - those need to be escaped for sed
echo "$VERSION" > /opt/adsb/adsb.im.version
SEDVERSION=${VERSION//\//\\\/}
sed -i "s/BASE_VERSION=.*/BASE_VERSION=$SEDVERSION/" /opt/adsb/config/.env
sed -i "s/\"_ADSBIM_BASE_VERSION\": \"[^\"]*\"/\"_ADSBIM_BASE_VERSION\": \"$SEDVERSION\"/" /opt/adsb/config/config.json

# if there is any special handling in the adsb-setup app for changes to the config files,
# env var names, etc (like in the v1.2.3->v1.3.0 upgrade), we need to run that
# BEFORE we update the Docker containers so that things align properly
# for this we don't want to restart the service, but manually run the script with the
# correct arguments to do that
# this also moves potentially updated yml files into the config folder
# also updates .env/config.json with new container versions from docker.image.versions
python3 /opt/adsb/adsb-setup/app.py --update-config || true # this always exits 1 and that's fine

echo "$(date -u +"%FT%T.%3NZ") finally, trigger a container upgrade so that they match the new image"
/opt/adsb/docker-update-adsb-im

echo "$(date -u +"%FT%T.%3NZ") restart the service"
trap - EXIT

kill_wait_app

systemctl restart adsb-setup.service

echo "$(date -u +"%FT%T.%3NZ") update to ${VERSION} complete"
